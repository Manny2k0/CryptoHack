from Crypto.Util.number import long_to_bytes, gcd
import decimal
from gmpy2 import *

# Function to find the prime factors p and q of modulus n
def find_prime_factors():
    # Provided values: d, e, and n
    d_value = 2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097
    e_value = 0x10001
    modulus_n = 21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771
    k_value = d_value * e_value - 1
    t_value = bit_scan1(k_value)

    # List of prime numbers under 1000
    prime_numbers = []
    for num in range(2, 1000):
        if all(num % i != 0 for i in range(2, num)):
            prime_numbers.append(num)

    # Try to find the factors of 'n'
    trivial_sqrt_set = {1, modulus_n - 1}
    for prime in prime_numbers:
        for j in range(1, t_value + 1):
            x_value = pow(prime, k_value >> j, modulus_n)
            if pow(x_value, 2, modulus_n) == 1:
                if x_value in trivial_sqrt_set: continue
                factor_p = gcd(x_value - 1, modulus_n)
                factor_q = modulus_n // factor_p
                if factor_q > factor_p: factor_p, factor_q = factor_q, factor_p
                return factor_p, factor_q, modulus_n

# Function to decrypt the ciphertext with the calculated private key
def decrypt_message(secret_key):
    prime_p, prime_q, modulus_n = secret_key
    assert prime_p * prime_q == modulus_n
    phi_n = (prime_p - 1) * (prime_q - 1)
    
    # List of possible public exponents e
    e_values = [106979, 108533, 69557, 97117, 103231]
    ciphertext_value = 20304610279578186738172766224224793119885071262464464448863461184092225736054747976985179673905441502689126216282897704508745403799054734121583968853999791604281615154100736259131453424385364324630229671185343778172807262640709301838274824603101692485662726226902121105591137437331463201881264245562214012160875177167442010952439360623396658974413900469093836794752270399520074596329058725874834082188697377597949405779039139194196065364426213208345461407030771089787529200057105746584493554722790592530472869581310117300343461207750821737840042745530876391793484035024644475535353227851321505537398888106855012746117
    
    # Decrypt the ciphertext with different exponents
    for e in e_values:
        private_exponent = invert(e, phi_n)
        ciphertext_value = pow(ciphertext_value, private_exponent, modulus_n)
    
    # Convert the decrypted message from a long integer to bytes
    print(long_to_bytes(ciphertext_value))

# Function to find the bit position of the least significant 1 bit
def bit_scan1(i):
    return (i & -i).bit_length() - 1

# Main function
if __name__ == '__main__':
    decrypt_message(find_prime_factors())
    print("Self-test OK")
