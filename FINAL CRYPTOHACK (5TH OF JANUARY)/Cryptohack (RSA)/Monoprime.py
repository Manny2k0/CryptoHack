from Crypto.Util.number import long_to_bytes

# Given large values for 'n', public exponent 'e', ciphertext 'ct', and private exponent 'd'
modulus_n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591
public_exponent = 65537
ciphertext = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

# Compute the private exponent 'd' using the modular inverse of 'e' modulo (n-1)
private_exponent = pow(public_exponent, -1, modulus_n - 1)

# Decrypt the ciphertext using the formula m = ct^d mod n
decrypted_message = pow(ciphertext, private_exponent, modulus_n)

# Convert the decrypted message (m) from a long integer to hexadecimal
hex_message = hex(decrypted_message)[2:]

# Print the decrypted message as bytes
print(bytes.fromhex(hex_message))
